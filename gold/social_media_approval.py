"""
Social Media Approval Workflow for AI Employee

This module handles the approval workflow for social media posts.
Posts are created as drafts and require human approval before publishing.
"""
import time
import logging
from pathlib import Path
from datetime import datetime
import json
import sys
import os
import shutil

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'gold'))

from config_loader import get_env_variable

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class SocialMediaApprovalWorkflow:
    """Handles approval workflow for social media posts"""

    def __init__(self, vault_path: str):
        self.vault_path = Path(vault_path)
        
        # Directories for approval workflow
        self.social_posts_dir = self.vault_path / "Social_Posts"
        self.pending_approval_dir = self.vault_path / "Plans" / "Pending_Approval" / "Social_Media"
        self.approved_dir = self.vault_path / "Plans" / "Approved" / "Social_Media"
        self.rejected_dir = self.vault_path / "Plans" / "Rejected" / "Social_Media"
        self.published_dir = self.vault_path / "Social_Posts" / "Published"
        
        # Create all directories
        for dir_path in [self.pending_approval_dir, self.approved_dir, 
                         self.rejected_dir, self.published_dir]:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Platform integrations
        self.twitter_api_configured = self._check_twitter_credentials()
        self.linkedin_api_configured = self._check_linkedin_credentials()

    def _check_twitter_credentials(self) -> bool:
        """Check if Twitter API credentials are configured"""
        required = ['TWITTER_API_KEY', 'TWITTER_API_SECRET', 
                   'TWITTER_ACCESS_TOKEN', 'TWITTER_ACCESS_TOKEN_SECRET']
        return all(get_env_variable(cred) for cred in required)

    def _check_linkedin_credentials(self) -> bool:
        """Check if LinkedIn API credentials are configured"""
        required = ['LINKEDIN_ACCESS_TOKEN', 'LINKEDIN_PERSON_URN']
        return all(get_env_variable(cred) for cred in required)

    def submit_for_approval(self, post_file: Path, platform: str, 
                           reason: str = "Scheduled social media post") -> Path:
        """
        Submit a draft post for approval.
        
        Args:
            post_file: Path to the draft post file
            platform: Target platform (twitter, facebook, instagram, linkedin)
            reason: Reason for this post
            
        Returns:
            Path to the approval request file
        """
        if not post_file.exists():
            logger.error(f"Post file does not exist: {post_file}")
            return None

        # Read the post content
        post_content = post_file.read_text(encoding='utf-8')

        # Extract post text from the markdown
        post_text = self._extract_post_content(post_content)

        # Create approval request file
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        approval_filename = f"SOCIAL_APPROVAL_{platform.upper()}_{timestamp}.md"
        approval_path = self.pending_approval_dir / approval_filename

        approval_content = f"""---
type: social_media_approval
platform: {platform}
status: pending
created: {datetime.now().isoformat()}
source_file: {str(post_file)}
reason: {reason}
requires_api: {self._platform_requires_api(platform)}
---

# Social Media Approval Request

## Platform
**{platform.upper()}**

## Post Content
```
{post_text}
```

## Details
- **Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Platform:** {platform.upper()}
- **Reason:** {reason}
- **API Configured:** {'Yes' if self._platform_requires_api(platform) else 'No (Draft only)'}

## Instructions

### To Approve:
1. Review the post content above
2. Move this file to: `Plans/Approved/Social_Media/`
3. The post will be automatically published (if API configured) or marked for manual posting

### To Reject:
1. Move this file to: `Plans/Rejected/Social_Media/`
2. Add a comment explaining why (optional)

### To Modify:
1. Edit the post content in the source file: `{post_file}`
2. Delete this approval request
3. Re-submit for approval

---
*This approval request was automatically generated by the AI Employee*
"""
        
        approval_path.write_text(approval_content)
        logger.info(f"Created approval request: {approval_path.name}")
        
        # Update the original post status
        self._update_post_status(post_file, 'pending_approval')
        
        return approval_path

    def _extract_post_content(self, markdown_content: str) -> str:
        """Extract the actual post content from markdown file"""
        lines = markdown_content.split('\n')
        in_content = False
        content_lines = []
        
        for line in lines:
            if line.startswith('## Content') or line.startswith('## Caption'):
                in_content = True
                continue
            elif line.startswith('## ') and in_content:
                break
            elif in_content and not line.startswith('---'):
                content_lines.append(line)
        
        return '\n'.join(content_lines).strip() if content_lines else markdown_content[:500]

    def _platform_requires_api(self, platform: str) -> bool:
        """Check if platform requires API for posting"""
        api_platforms = ['twitter', 'linkedin']
        return platform.lower() in api_platforms

    def _update_post_status(self, post_file: Path, status: str):
        """Update the status field in a post file"""
        if not post_file.exists():
            return

        content = post_file.read_text(encoding='utf-8')

        # Replace status line
        if 'status:' in content:
            content = content.replace(
                f"status: {content.split('status:')[1].split('\n')[0].strip()}",
                f"status: {status}"
            )
        else:
            # Add status after type line
            content = content.replace(
                'type:',
                f'type:\nstatus: {status}\noriginal_type:'
            )
        
        post_file.write_text(content)

    def process_approved_posts(self) -> dict:
        """
        Process all approved posts and publish them.
        
        Returns:
            Dictionary with processing results
        """
        results = {
            'processed': 0,
            'published': 0,
            'failed': 0,
            'manual_required': 0,
            'details': []
        }
        
        # Get all approved files
        approved_files = list(self.approved_dir.glob("SOCIAL_APPROVAL_*.md"))
        
        for approval_file in approved_files:
            results['processed'] += 1

            try:
                # Read approval file
                content = approval_file.read_text(encoding='utf-8')

                # Extract metadata
                platform = self._extract_metadata(content, 'platform')
                source_file = Path(self._extract_metadata(content, 'source_file'))

                # Get post content
                if source_file.exists():
                    post_content = source_file.read_text(encoding='utf-8')
                    post_text = self._extract_post_content(post_content)

                    # Publish based on platform
                    publish_result = self._publish_post(platform, post_text, post_content)

                    if publish_result['success']:
                        results['published'] += 1
                        
                        # Move to published folder
                        published_file = self.published_dir / f"PUBLISHED_{source_file.name}"
                        shutil.copy2(source_file, published_file)
                        
                        # Add publication record
                        self._add_publication_record(published_file, publish_result)
                        
                        results['details'].append({
                            'file': str(source_file),
                            'platform': platform,
                            'status': 'published',
                            'result': publish_result
                        })
                        
                        # Move approval file to archived
                        archived_approval = self.approved_dir / f"ARCHIVED_{approval_file.name}"
                        approval_file.rename(archived_approval)
                        
                    else:
                        results['failed'] += 1
                        results['details'].append({
                            'file': str(source_file),
                            'platform': platform,
                            'status': 'failed',
                            'error': publish_result.get('error', 'Unknown error')
                        })
                        
                else:
                    results['manual_required'] += 1
                    results['details'].append({
                        'file': str(source_file),
                        'platform': platform,
                        'status': 'source_not_found',
                        'error': 'Source post file not found'
                    })
                    
            except Exception as e:
                results['failed'] += 1
                results['details'].append({
                    'file': str(approval_file),
                    'status': 'error',
                    'error': str(e)
                })
                logger.error(f"Error processing approval {approval_file.name}: {e}")
        
        return results

    def _publish_post(self, platform: str, post_text: str, full_content: str) -> dict:
        """
        Publish a post to the specified platform.
        
        Args:
            platform: Target platform
            post_text: The actual post content
            full_content: Full markdown content
            
        Returns:
            Dictionary with publish result
        """
        if platform.lower() == 'twitter':
            return self._publish_to_twitter(post_text)
        elif platform.lower() == 'linkedin':
            return self._publish_to_linkedin(post_text)
        elif platform.lower() in ['facebook', 'instagram']:
            # These are simulated for now
            return self._simulate_publish(platform, post_text)
        else:
            return {'success': False, 'error': f'Unknown platform: {platform}'}

    def _publish_to_twitter(self, post_text: str) -> dict:
        """Publish to Twitter using API"""
        try:
            import tweepy
            
            # Get credentials
            api_key = get_env_variable('TWITTER_API_KEY')
            api_secret = get_env_variable('TWITTER_API_SECRET')
            access_token = get_env_variable('TWITTER_ACCESS_TOKEN')
            access_token_secret = get_env_variable('TWITTER_ACCESS_TOKEN_SECRET')
            
            if not all([api_key, api_secret, access_token, access_token_secret]):
                return {'success': False, 'error': 'Twitter credentials not configured'}
            
            # Authenticate and post
            client = tweepy.Client(
                consumer_key=api_key,
                consumer_secret=api_secret,
                access_token=access_token,
                access_token_secret=access_token_secret
            )
            
            # Post tweet
            response = client.create_tweet(text=post_text[:280])
            tweet_id = response.data['id']
            
            logger.info(f"Tweet published successfully: {tweet_id}")
            
            return {
                'success': True,
                'platform': 'twitter',
                'post_id': tweet_id,
                'url': f'https://twitter.com/status/{tweet_id}'
            }
            
        except ImportError:
            return {'success': False, 'error': 'tweepy not installed'}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _publish_to_linkedin(self, post_text: str) -> dict:
        """Publish to LinkedIn using API"""
        try:
            import requests
            
            # Get credentials
            access_token = get_env_variable('LINKEDIN_ACCESS_TOKEN')
            person_urn = get_env_variable('LINKEDIN_PERSON_URN')
            
            if not all([access_token, person_urn]):
                return {'success': False, 'error': 'LinkedIn credentials not configured'}
            
            # Post to LinkedIn
            headers = {
                'Authorization': f'Bearer {access_token}',
                'Content-Type': 'application/json',
                'X-Restli-Protocol-Version': '2.0.0'
            }
            
            payload = {
                'author': person_urn,
                'lifecycleState': 'PUBLISHED',
                'specificContent': {
                    'com.linkedin.ugc.ShareContent': {
                        'shareCommentary': {'text': post_text},
                        'shareMediaCategory': 'NONE'
                    }
                },
                'visibility': {
                    'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC'
                }
            }
            
            response = requests.post(
                'https://api.linkedin.com/v2/ugcPosts',
                headers=headers,
                json=payload
            )
            
            if response.status_code in [200, 201]:
                post_id = response.json().get('id', 'unknown')
                logger.info(f"LinkedIn post published successfully: {post_id}")
                
                return {
                    'success': True,
                    'platform': 'linkedin',
                    'post_id': post_id
                }
            else:
                return {'success': False, 'error': f'LinkedIn API error: {response.status_code}'}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _simulate_publish(self, platform: str, post_text: str) -> dict:
        """Simulate publishing for platforms without API"""
        logger.info(f"Simulated publish to {platform}: {post_text[:50]}...")
        
        return {
            'success': True,
            'platform': platform,
            'post_id': f'SIMULATED_{int(time.time())}',
            'note': f'{platform} posting simulated - manual posting required'
        }

    def _add_publication_record(self, published_file: Path, publish_result: dict):
        """Add publication metadata to the published file"""
        content = published_file.read_text(encoding='utf-8')

        # Add publication info
        pub_info = f"""
## Publication Record
- **Published:** {datetime.now().isoformat()}
- **Platform:** {publish_result.get('platform', 'unknown')}
- **Post ID:** {publish_result.get('post_id', 'unknown')}
- **Status:** {'Success' if publish_result.get('success') else 'Failed'}
"""

        if 'url' in publish_result:
            pub_info += f"- **URL:** {publish_result['url']}\n"

        content += pub_info
        published_file.write_text(content, encoding='utf-8')

    def _extract_metadata(self, content: str, field: str) -> str:
        """Extract a metadata field from markdown frontmatter"""
        for line in content.split('\n'):
            if line.startswith(f'{field}:'):
                return line.split(':', 1)[1].strip()
        return ''

    def get_approval_status(self) -> dict:
        """Get current status of all approval requests"""
        return {
            'pending': len(list(self.pending_approval_dir.glob("*.md"))),
            'approved': len(list(self.approved_dir.glob("*.md"))),
            'rejected': len(list(self.rejected_dir.glob("*.md"))),
            'published': len(list(self.published_dir.glob("*.md")))
        }

    def create_approval_dashboard(self) -> Path:
        """Create a dashboard showing approval status"""
        status = self.get_approval_status()
        
        dashboard_path = self.vault_path / "Social_Posts" / "APPROVAL_DASHBOARD.md"
        
        dashboard_content = f"""---
type: social_media_approval_dashboard
generated: {datetime.now().isoformat()}
---

# Social Media Approval Dashboard

## Status Overview

| Status | Count |
|--------|-------|
| üî¥ Pending Approval | {status['pending']} |
| üü¢ Approved | {status['approved']} |
| ‚ùå Rejected | {status['rejected']} |
| ‚úÖ Published | {status['published']} |

## API Configuration

| Platform | Status |
|----------|--------|
| Twitter | {'‚úÖ Configured' if self.twitter_api_configured else '‚ùå Not Configured'} |
| LinkedIn | {'‚úÖ Configured' if self.linkedin_api_configured else '‚ùå Not Configured'} |
| Facebook | ‚ö†Ô∏è Simulated (Manual) |
| Instagram | ‚ö†Ô∏è Simulated (Manual) |

## Workflow

1. **AI creates draft** ‚Üí Social_Posts/
2. **Submit for approval** ‚Üí Plans/Pending_Approval/Social_Media/
3. **Human reviews** ‚Üí Move to Approved or Rejected
4. **Auto-publish** ‚Üí If approved and API configured
5. **Archive** ‚Üí Social_Posts/Published/

## Pending Approvals

"""

        # List pending approvals
        pending_files = list(self.pending_approval_dir.glob("*.md"))
        if pending_files:
            for pf in pending_files:
                content = pf.read_text(encoding='utf-8')
                platform = self._extract_metadata(content, 'platform')
                created = self._extract_metadata(content, 'created')
                dashboard_content += f"- **{pf.name}** ({platform}) - Created: {created}\n"
        else:
            dashboard_content += "*No pending approvals*\n"

        dashboard_content += f"\n---\n*Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n"

        dashboard_path.write_text(dashboard_content, encoding='utf-8')
        logger.info(f"Created approval dashboard: {dashboard_path}")

        return dashboard_path


def main():
    """Main function to demonstrate approval workflow"""
    vault_path = Path("../AI_Employee_Vault")
    
    workflow = SocialMediaApprovalWorkflow(str(vault_path))
    
    print("=== Social Media Approval Workflow Demo ===\n")
    
    # Find existing draft posts
    draft_posts = list((vault_path / "Social_Posts").glob("TWITTER_POST_*.md"))
    
    if draft_posts:
        # Submit first draft for approval
        draft = draft_posts[0]
        print(f"Submitting for approval: {draft.name}")
        
        approval_file = workflow.submit_for_approval(
            draft, 
            platform='twitter',
            reason='Demo: Testing approval workflow'
        )
        
        if approval_file:
            print(f"[OK] Approval request created: {approval_file.name}")
    
    # Process any approved posts
    print("\nProcessing approved posts...")
    results = workflow.process_approved_posts()
    print(f"Results: {results}")
    
    # Show status
    print("\n=== Approval Status ===")
    status = workflow.get_approval_status()
    for key, value in status.items():
        print(f"{key.capitalize()}: {value}")
    
    # Create dashboard
    print("\nCreating approval dashboard...")
    dashboard = workflow.create_approval_dashboard()
    print(f"Dashboard created: {dashboard}")
    
    print("\n=== Demo Complete ===")


if __name__ == "__main__":
    main()
