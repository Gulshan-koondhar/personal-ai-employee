"""
Twitter Integration for AI Employee

This module handles Twitter (X) integration for the Gold Tier.
"""
import time
import logging
from pathlib import Path
from datetime import datetime
import json
import sys
import os

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class TwitterIntegrator:
    """Handles Twitter (X) integration"""

    def __init__(self, vault_path: str):
        self.vault_path = Path(vault_path)
        self.needs_action = self.vault_path / "Needs_Action"
        self.social_posts = self.vault_path / "Social_Posts"
        self.social_posts.mkdir(exist_ok=True)

    def create_tweet(self, content: str, thread: list = None, media_paths: list = None) -> dict:
        """
        Create a Twitter post (tweet) draft (simulated for this implementation).

        Args:
            content: Main tweet content (max 280 characters for single tweet)
            thread: List of additional tweets for a thread (optional)
            media_paths: List of media file paths (optional)

        Returns:
            Dictionary with success status and tweet information
        """
        # Validate content length
        if len(content) > 280:
            logger.warning(f"Tweet content exceeds 280 characters ({len(content)}). Truncating...")
            content = content[:277] + "..."

        logger.info(f"Creating Twitter post: {content[:50]}...")

        tweet_filename = f"TWITTER_POST_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        post_path = self.social_posts / tweet_filename

        post_content = f"""---
type: twitter_post
status: draft
created: {datetime.now().isoformat()}
scheduled: {datetime.now().isoformat()}
platform: twitter
character_count: {len(content)}
---

# Twitter Post Draft

## Content
{content}

## Thread
{self._format_thread(thread) if thread else 'No thread'}

## Media Attachments
{self._format_media_list(media_paths) if media_paths else 'No media'}

## Suggested Actions
- [ ] Review character count and content
- [ ] Approve for posting
- [ ] Schedule optimal posting time (usually 8-10 AM or 7-9 PM)
- [ ] Monitor engagement after posting
- [ ] Track retweets and likes

## Hashtags
{self._generate_hashtags(content)}

## Notes
This tweet was automatically generated by the AI Employee for Twitter/X.
"""
        post_path.write_text(post_content, encoding='utf-8')

        return {
            "success": True,
            "post_id": tweet_filename,
            "message": f"Twitter post draft created: {tweet_filename}",
            "character_count": len(content)
        }

    def _format_thread(self, thread: list) -> str:
        """Format thread content for display."""
        if not thread:
            return "No thread"
        formatted = []
        for i, tweet in enumerate(thread, 1):
            # Truncate if needed
            if len(tweet) > 280:
                tweet = tweet[:277] + "..."
            formatted.append(f"{i}. {tweet}")
        return "\n".join(formatted)

    def _format_media_list(self, media_paths: list) -> str:
        """Format media list for display."""
        if not media_paths:
            return "No media"
        return "\n".join([f"- {path}" for path in media_paths])

    def _generate_hashtags(self, content: str) -> str:
        """Generate relevant hashtags based on content."""
        # Simple hashtag generation based on content
        words = content.lower().split()
        business_keywords = [
            'innovation', 'business', 'tech', 'startup', 'entrepreneur',
            'marketing', 'growth', 'success', 'leadership', 'future'
        ]

        hashtags = []
        for word in words:
            clean_word = ''.join(c for c in word if c.isalnum())
            if clean_word in business_keywords and len(clean_word) > 3:
                hashtags.append(f"#{clean_word}")

        # Add some general hashtags
        general_hashtags = ['#AI', '#Automation', '#Business']
        hashtags.extend(general_hashtags)

        # Remove duplicates and limit to 5
        unique_hashtags = list(dict.fromkeys(hashtags))[:5]

        return " ".join(unique_hashtags) if unique_hashtags else "#AI #Business #Automation"

    def schedule_tweet(self, tweet_file: Path, schedule_time: str) -> dict:
        """
        Schedule a tweet for later publishing.

        Args:
            tweet_file: Path to the tweet file
            schedule_time: Schedule time in ISO format

        Returns:
            Dictionary with success status
        """
        logger.info(f"Scheduling tweet: {tweet_file.name} for {schedule_time}")

        # Update the tweet file with scheduling information
        content = tweet_file.read_text()
        updated_content = content.replace(
            'status: draft',
            'status: scheduled'
        ).replace(
            'scheduled: null',
            f'scheduled: {schedule_time}'
        )

        tweet_file.write_text(updated_content)

        return {
            "success": True,
            "message": f"Tweet scheduled for {schedule_time}"
        }

    def create_thread(self, main_topic: str, points: list) -> dict:
        """
        Create a multi-tweet thread on a specific topic.

        Args:
            main_topic: Main topic of the thread
            points: List of points to cover in the thread

        Returns:
            Dictionary with success status and thread information
        """
        logger.info(f"Creating Twitter thread on topic: {main_topic}")

        # Create the thread content
        thread_content = [
            f"Let's talk about {main_topic}. Here's what you need to know: ðŸ§µ"
        ]

        for i, point in enumerate(points, 1):
            formatted_point = f"{i}/ {point}"
            # Ensure it fits within Twitter's limits
            if len(formatted_point) > 250:  # Leave room for the numbering
                formatted_point = formatted_point[:247] + "..."
            thread_content.append(formatted_point)

        thread_content.append(
            f"That's my take on {main_topic}. What's yours? #AI #Business"
        )

        thread_filename = f"TWITTER_THREAD_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        thread_path = self.social_posts / thread_filename

        thread_text = "\n\n".join(thread_content)

        thread_content_md = f"""---
type: twitter_thread
status: draft
created: {datetime.now().isoformat()}
scheduled: {datetime.now().isoformat()}
platform: twitter
tweet_count: {len(thread_content)}
---

# Twitter Thread Draft

## Main Topic
{main_topic}

## Thread Content
{thread_text}

## Tweet Breakdown
{chr(10).join([f'{i+1}. "{tweet}"' for i, tweet in enumerate(thread_content)])}

## Suggested Actions
- [ ] Review thread flow and content
- [ ] Approve for posting as thread
- [ ] Schedule optimal posting time
- [ ] Monitor engagement after posting
- [ ] Track thread completion rate

## Notes
This thread was automatically generated by the AI Employee for Twitter/X.
"""
        thread_path.write_text(thread_content_md, encoding='utf-8')

        return {
            "success": True,
            "thread_id": thread_filename,
            "message": f"Twitter thread draft created: {thread_filename}",
            "tweet_count": len(thread_content)
        }

    def generate_engagement_post(self, content_type: str = "question") -> dict:
        """
        Generate a post designed to drive engagement.

        Args:
            content_type: Type of engagement post ('question', 'poll', 'opinion', 'update')

        Returns:
            Dictionary with success status and post information
        """
        templates = {
            "question": [
                "What's your take on this? I'd love to hear your thoughts! ðŸ’­",
                "How do you approach this? I'm curious about your experience. ðŸ¤”",
                "This is changing the game. What do you think? ðŸš€"
            ],
            "poll": [
                "I'm curious - which approach do you prefer and why?",
                "Would you do this differently? Let me know your thoughts! ðŸ“Š",
                "This is a hot topic. Where do you stand? âš–ï¸"
            ],
            "opinion": [
                "My take is... (see thread). What's yours? ðŸ§µ",
                "I believe this could be a game-changer. Thoughts? ðŸ’­",
                "Here's my perspective. How does it align with yours? ðŸ¤”"
            ],
            "update": [
                "Just wanted to share this with the community. What do you think?",
                "Exciting developments in this space. Your thoughts? ðŸŒŸ",
                "What we're learning in this area is fascinating. What's your experience?"
            ]
        }

        import random
        template = random.choice(templates.get(content_type, templates["question"]))

        content = f""" excited about recent developments in this space! {template} #Engagement #{content_type.title()}"""

        return self.create_tweet(content)

    def post_tweet(self, content: str, thread: list = None, media_paths: list = None) -> dict:
        """
        Post a tweet directly to Twitter using API credentials.

        Args:
            content: Main tweet content (max 280 characters for single tweet)
            thread: List of additional tweets for a thread (optional)
            media_paths: List of media file paths (optional)

        Returns:
            Dictionary with success status and tweet information
        """
        try:
            # Import required modules for Twitter API
            import tweepy
            import os
            from pathlib import Path

            # Load environment variables
            env_path = Path('../gold/.env')
            if env_path.exists():
                with open(env_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#') and '=' in line:
                            key, value = line.split('=', 1)
                            key = key.strip()
                            value = value.strip().strip('"\'')
                            if key not in os.environ:
                                os.environ[key] = value

            # Get Twitter API credentials
            api_key = os.environ.get('TWITTER_API_KEY')
            api_secret = os.environ.get('TWITTER_API_SECRET')
            access_token = os.environ.get('TWITTER_ACCESS_TOKEN')
            access_token_secret = os.environ.get('TWITTER_ACCESS_TOKEN_SECRET')
            bearer_token = os.environ.get('TWITTER_BEARER_TOKEN')  # Optional: if available in .env

            if not all([api_key, api_secret, access_token, access_token_secret]):
                return {
                    "success": False,
                    "message": "Twitter API credentials not properly configured"
                }

            # Initialize Twitter API client v2 with proper authentication
            if bearer_token:
                client = tweepy.Client(
                    bearer_token=bearer_token,
                    consumer_key=api_key,
                    consumer_secret=api_secret,
                    access_token=access_token,
                    access_token_secret=access_token_secret,
                    wait_on_rate_limit=True
                )
            else:
                # If no bearer token provided, try to initialize with just the other credentials
                client = tweepy.Client(
                    consumer_key=api_key,
                    consumer_secret=api_secret,
                    access_token=access_token,
                    access_token_secret=access_token_secret,
                    wait_on_rate_limit=True
                )

            # Validate content length
            if len(content) > 280:
                logger.warning(f"Tweet content exceeds 280 characters ({len(content)}). Truncating...")
                content = content[:277] + "..."

            # Handle thread if provided
            if thread:
                # Post the first tweet
                response = client.create_tweet(text=content)
                first_tweet_id = response.data['id']

                # Post subsequent tweets in the thread
                prev_tweet_id = first_tweet_id
                for tweet_text in thread:
                    if len(tweet_text) > 280:
                        tweet_text = tweet_text[:277] + "..."

                    # Reply to the previous tweet to create a thread
                    response = client.create_tweet(text=tweet_text, in_reply_to_tweet_id=prev_tweet_id)
                    prev_tweet_id = response.data['id']

                tweet_id = first_tweet_id
            else:
                # Post single tweet
                response = client.create_tweet(text=content)
                tweet_id = response.data['id']

            # Create a record of the posted tweet
            tweet_filename = f"TWITTER_POSTED_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            post_path = self.social_posts / tweet_filename

            post_content = f"""---
type: twitter_post
status: published
created: {datetime.now().isoformat()}
platform: twitter
tweet_id: {tweet_id}
character_count: {len(content)}
---

# Twitter Post

## Content
{content}

## Thread
{self._format_thread(thread) if thread else 'No thread'}

## Media Attachments
{self._format_media_list(media_paths) if media_paths else 'No media'}

## Posted
{datetime.now().isoformat()}

## Notes
This tweet was successfully published to Twitter/X by the AI Employee.
Tweet ID: {tweet_id}
"""
            post_path.write_text(post_content, encoding='utf-8')

            return {
                "success": True,
                "tweet_id": tweet_id,
                "message": f"Twitter post published successfully: {tweet_filename}",
                "character_count": len(content)
            }

        except Exception as e:
            # If API fails, create a draft instead
            logger.error(f"Failed to post to Twitter: {str(e)}")
            return self.create_tweet(content, thread, media_paths)

    def generate_summary_report(self) -> dict:
        """
        Generate a Twitter activity summary report.

        Returns:
            Dictionary with summary statistics
        """
        # Count Twitter-related draft posts
        all_posts = list(self.social_posts.glob("*_POST_*.md"))
        twitter_posts = [p for p in all_posts if 'TWITTER' in p.name.upper()]

        # Count threads separately
        twitter_threads = list(self.social_posts.glob("*TWITTER_THREAD_*.md"))

        summary = {
            "generated_at": datetime.now().isoformat(),
            "total_twitter_drafts": len(twitter_posts),
            "twitter_threads": len(twitter_threads),
            "twitter_posts": len(twitter_posts) - len(twitter_threads),  # Not counting threads as regular posts
            "latest_twitter_posts": [p.name for p in twitter_posts[-3:]],  # Last 3 posts
            "latest_threads": [t.name for t in twitter_threads[-2:]]  # Last 2 threads
        }

        # Create a Twitter summary file
        summary_filename = f"Twitter_Summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        summary_path = self.social_posts / summary_filename

        summary_content = f"""---
type: twitter_summary
created: {datetime.now().isoformat()}
---

# Twitter Activity Summary

## Statistics
- Total draft posts: {summary['total_twitter_drafts']}
- Regular posts: {summary['twitter_posts']}
- Threads: {summary['twitter_threads']}

## Latest Posts
{chr(10).join([f"- {post}" for post in summary['latest_twitter_posts']])}

## Latest Threads
{chr(10).join([f"- {thread}" for thread in summary['latest_threads']])}

## Generated
{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Notes
This Twitter summary was automatically generated by the AI Employee.
"""
        summary_path.write_text(summary_content)

        return summary

def main():
    """Main function to demonstrate Twitter integration"""
    vault_path = Path("../AI_Employee_Vault")

    # Create vault structure if needed
    (vault_path / "Needs_Action").mkdir(exist_ok=True)

    twitter = TwitterIntegrator(str(vault_path))

    # Create a sample tweet
    print("Creating sample tweet...")
    tweet_result = twitter.create_tweet(
        "excited about the latest developments in AI automation! The future of work is being shaped by intelligent agents that can handle complex tasks autonomously. #AI #Automation"
    )
    print(f"Tweet result: {tweet_result}")

    # Create a thread
    print("\nCreating sample thread...")
    thread_result = twitter.create_thread(
        "AI Automation",
        [
            "AI agents are changing how we think about work and productivity",
            "The key is building systems that augment human capabilities",
            "Success requires careful balance of automation and human oversight",
            "The future belongs to those who embrace this transformation",
            "What's your experience with AI tools?"
        ]
    )
    print(f"Thread result: {thread_result}")

    # Create an engagement post
    print("\nCreating engagement post...")
    engagement_result = twitter.generate_engagement_post("question")
    print(f"Engagement post result: {engagement_result}")

    # Generate summary
    print("\nGenerating Twitter summary...")
    summary = twitter.generate_summary_report()
    print(f"Summary: {summary}")

    print("\nTwitter integration demo completed!")

if __name__ == "__main__":
    main()